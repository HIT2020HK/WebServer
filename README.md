
半同步/半反应堆线程池
===============
使用一个工作队列完全解除了主线程和工作线程的耦合关系：主线程往工作队列中插入任务，工作线程通过竞争来取得任务并执行它。
> * 同步I/O模拟proactor模式
> * 半同步/半反应堆
> * 线程池


RAII 全称是“Resource Acquisition is Initialization”，直译过来是 “资源获取即初始化”.
在构造函数中申请分配资源，在析构函数中释放资源

RAII的核心思想是将资源或者状态与对象的生命周期绑定，通过C++的语言机制，实现资源和状态的安全管理,智能指针是RAII最好的例子

信号量的取值可以是任何自然数，最常用的，最简单的信号量是二进制信号量，只有0和1两个值.
        sem_init函数用于初始化一个未命名的信号量

        sem_destory函数用于销毁信号量

        sem_wait函数将以原子操作方式将信号量减一,信号量为0时,sem_wait阻塞

        sem_post函数以原子操作方式将信号量加一,信号量大于0时,唤醒调用sem_post的线程

以上，成功返回0，失败返回errno


#include <pthread.h>
2int pthread_create (pthread_t *thread_tid,              // 返回新生成的线程的id
3                    const pthread_attr_t *attr,         // 指向线程属性的指针,通常设置为NULL
4                    void * (*start_routine) (void *),   // 处理线程函数的地址
5                    void *arg);                         // start_routine()中的参数

函数原型中的第三个参数，为函数指针，指向处理线程函数的地址。该函数，要求为静态函数。如果处理线程函数为类成员函数时，需要将其设置为静态成员函数。
pthread_create的函数原型中第三个参数的类型为函数指针，指向的线程处理函数参数类型为(void *),若线程函数为类成员函数，则this指针会作为默认的参数被传进函数中，从而和线程函数参数(void*)不能匹配，不能通过编译。

静态成员函数就没有这个问题，里面没有this指针。